import { BaseService } from './base.service'

export interface Vulnerability {
  id: string
  title: string
  description: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  cvss: number
  status: 'open' | 'in_progress' | 'resolved' | 'closed'
  affectedSystems: string[]
  discoveryDate: string
  lastUpdated: string
  remediation?: {
    steps: string[]
    estimatedTime: string
    priority: 'low' | 'medium' | 'high'
  }
}

export class VulnerabilityService extends BaseService {
  async getVulnerabilities() {
    try {
      const data = await this.liquidModel.getVulnerabilities()
      return this.transformVulnerabilities(data)
    } catch (error) {
      this.handleError(error)
    }
  }

  async getVulnerabilityTrends() {
    try {
      const data = await this.liquidModel.getVulnerabilityTrends()
      return this.transformTrends(data)
    } catch (error) {
      this.handleError(error)
    }
  }

  async getForecast() {
    try {
      const data = await this.liquidModel.getVulnerabilityForecast()
      return this.transformForecast(data)
    } catch (error) {
      this.handleError(error)
    }
  }

  private transformVulnerabilities(data: any[]): Vulnerability[] {
    return data.map(vuln => ({
      id: vuln.id,
      title: vuln.title,
      description: vuln.description,
      severity: vuln.severity.toLowerCase(),
      cvss: vuln.cvss_score,
      status: vuln.status.toLowerCase(),
      affectedSystems: vuln.affected_systems,
      discoveryDate: vuln.discovery_date,
      lastUpdated: vuln.last_updated,
      remediation: vuln.remediation ? {
        steps: vuln.remediation.steps,
        estimatedTime: vuln.remediation.estimated_time,
        priority: vuln.remediation.priority.toLowerCase()
      } : undefined
    }))
  }

  private transformTrends(data: any) {
    return {
      daily: data.daily_trends,
      weekly: data.weekly_trends,
      monthly: data.monthly_trends,
      byType: data.trends_by_type,
      bySeverity: data.trends_by_severity
    }
  }

  private transformForecast(data: any) {
    return {
      predictions: data.predictions,
      confidence: data.confidence_score,
      factors: data.contributing_factors,
      recommendations: data.recommendations
    }
  }
}
